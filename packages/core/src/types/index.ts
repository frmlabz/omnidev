// Capability Export Types (for capability developers)
export * from "./capability-export.js";

// Hooks Types - import for use in this file
import type { HooksConfig, CapabilityHooks } from "../hooks/types.js";

// Re-export all hooks types
export type {
	HooksConfig,
	HookEvent,
	HookType,
	HookMatcher,
	Hook,
	HookCommand,
	HookPrompt,
	HookValidationResult,
	HookValidationIssue,
	CapabilityHooks,
} from "../hooks/types.js";

// Capability Types
export interface CapabilityMetadata {
	id: string;
	name: string;
	version: string;
	description: string;
	/** Optional author information */
	author?: {
		name?: string;
		email?: string;
	};
	/** Optional metadata about the capability author and source */
	metadata?: {
		author?: string;
		repository?: string;
		license?: string;
		/** True if this capability was auto-generated by wrapping a skills repo */
		wrapped?: boolean;
		/** For wrapped capabilities: the full commit hash */
		commit?: string;
		/** True if this capability was auto-generated from omni.toml [mcps] section */
		generated_from_omni_toml?: boolean;
	};
}

export interface CapabilityExports {
	module?: string;
	gitignore?: string[];
}

export interface EnvDeclaration {
	required?: boolean;
	secret?: boolean;
	default?: string;
}

export interface SyncConfig {
	on_sync?: string;
}

export interface CliConfig {
	commands?: string[];
}

export interface CapabilityConfig {
	capability: CapabilityMetadata;
	exports?: CapabilityExports;
	env?: Record<string, EnvDeclaration | Record<string, never>>;
	mcp?: McpConfig;
	sync?: SyncConfig;
	cli?: CliConfig;
}

export type McpTransport = "stdio" | "sse" | "http";

export interface McpToolSchema {
	name: string;
	description: string;
	inputSchema: Record<string, unknown>;
}

/**
 * MCP server configuration supporting multiple transport types:
 *
 * - **stdio**: Local process using stdin/stdout (default)
 *   - Requires: command
 *   - Optional: args, env, cwd
 *
 * - **http**: Remote HTTP server (recommended for remote servers)
 *   - Requires: url
 *   - Optional: headers (for authentication)
 *
 * - **sse**: Server-Sent Events (deprecated, use http instead)
 *   - Requires: url
 *   - Optional: headers (for authentication)
 */
export interface McpConfig {
	/** Executable to run (required for stdio transport) */
	command?: string;
	/** Command arguments (stdio transport only) */
	args?: string[];
	/** Environment variables (stdio transport only) */
	env?: Record<string, string>;
	/** Working directory (stdio transport only) */
	cwd?: string;
	/** Transport type: stdio (default), http, or sse */
	transport?: McpTransport;
	/** URL for remote servers (required for http/sse transport) */
	url?: string;
	/** HTTP headers for authentication (http/sse transport only) */
	headers?: Record<string, string>;
	/** Tool schemas (optional, for documentation) */
	tools?: McpToolSchema[];
}

// Content Types
export interface Skill {
	name: string;
	description: string;
	instructions: string;
	capabilityId: string;
}

export interface Rule {
	name: string;
	content: string;
	capabilityId: string;
}

export interface Doc {
	name: string;
	content: string;
	capabilityId: string;
}

export type SubagentModel = "sonnet" | "opus" | "haiku" | "inherit";
export type SubagentPermissionMode =
	| "default"
	| "acceptEdits"
	| "dontAsk"
	| "bypassPermissions"
	| "plan";

export interface SubagentHookConfig {
	matcher?: string;
	hooks: {
		type: "command";
		command: string;
	}[];
}

export interface SubagentHooks {
	PreToolUse?: SubagentHookConfig[];
	PostToolUse?: SubagentHookConfig[];
	Stop?: SubagentHookConfig[];
}

export interface Subagent {
	/** Unique identifier using lowercase letters and hyphens */
	name: string;
	/** When Claude should delegate to this subagent */
	description: string;
	/** System prompt that guides the subagent's behavior */
	systemPrompt: string;
	/** Tools the subagent can use (inherits all if omitted) */
	tools?: string[];
	/** Tools to deny (removed from inherited or specified list) */
	disallowedTools?: string[];
	/** Model to use: sonnet, opus, haiku, or inherit */
	model?: SubagentModel;
	/** Permission mode for the subagent */
	permissionMode?: SubagentPermissionMode;
	/** Skills to load into the subagent's context at startup */
	skills?: string[];
	/** Lifecycle hooks scoped to this subagent */
	hooks?: SubagentHooks;
	/** Capability that provides this subagent */
	capabilityId: string;
}

export interface Command {
	/** Command name (used as /command-name) */
	name: string;
	/** Brief description of what this command does */
	description: string;
	/** Optional allowed tools specification (e.g., "Bash(git add:*), Bash(git status:*)") */
	allowedTools?: string;
	/** Command prompt (markdown content with support for $ARGUMENTS, $1, $2, !`commands`, @files) */
	prompt: string;
	/** Capability that provides this command */
	capabilityId: string;
}

// Capability Source Types
// Sources: local (manual), git (version via package.json)
export type CapabilitySourceType = "local" | "git";

/** Configuration for a Git-sourced capability */
export interface GitCapabilitySourceConfig {
	/** Source URL or shorthand (e.g., "github:user/repo", "git@github.com:...") */
	source: string;
	/** Git ref to checkout: tag, branch, or commit hash */
	ref?: string;
	/** Subdirectory within the repo containing the capability */
	path?: string;
}

/** Configuration for a local file-sourced capability */
export interface FileCapabilitySourceConfig {
	/** Source path with file:// prefix (e.g., "file://./capabilities/my-cap") */
	source: string;
}

/** Combined type for all capability source configurations */
export type CapabilitySourceConfig =
	| string // shorthand: "github:user/repo" or "file://./path"
	| GitCapabilitySourceConfig
	| FileCapabilitySourceConfig;

/**
 * Type guard to check if a source config is a FileCapabilitySourceConfig
 */
export function isFileSourceConfig(
	config: CapabilitySourceConfig,
): config is FileCapabilitySourceConfig {
	if (typeof config === "string") {
		return config.startsWith("file://");
	}
	return config.source.startsWith("file://");
}

/** Lock file entry for a capability (version tracking) */
export interface CapabilityLockEntry {
	/** Original source reference */
	source: string;
	/** Version from capability.toml or package.json */
	version: string;
	/** For git sources: exact commit hash */
	commit?: string;
	/** Pinned ref if specified */
	ref?: string;
	/** Last update timestamp (ISO 8601) */
	updated_at: string;
}

/** Lock file structure (omni.lock.toml at project root) */
export interface CapabilitiesLockFile {
	capabilities: Record<string, CapabilityLockEntry>;
}

/** Capabilities configuration section in omni.toml */
export interface CapabilitiesConfig {
	/** List of enabled capability IDs */
	enable?: string[];
	/** List of disabled capability IDs */
	disable?: string[];
	/** Capability sources: id -> source string or full config (git or file) */
	sources?: Record<string, CapabilitySourceConfig>;
	/** Capability groups: group name -> array of capability IDs */
	groups?: Record<string, string[]>;
}

// Config Types
export interface ProfileConfig {
	capabilities?: string[];
}

export interface OmniConfig {
	project?: string;
	active_profile?: string;
	always_enabled_capabilities?: string[];
	env?: Record<string, string>;
	profiles?: Record<string, ProfileConfig>;
	providers?: {
		enabled?: Provider[];
	};
	/** Capabilities configuration (enable/disable, sources) */
	capabilities?: CapabilitiesConfig;
	/** MCP server definitions that auto-generate capabilities */
	mcps?: Record<string, McpConfig>;
}

// Provider Types
export type Provider = "claude" | "codex" | "claude-code" | "cursor" | "opencode";

export interface ProviderConfig {
	provider?: Provider;
	providers?: Provider[];
}

export function getActiveProviders(config: ProviderConfig): Provider[] {
	if (config.providers) return config.providers;
	if (config.provider) return [config.provider];
	return ["claude"]; // Default
}

/** Runtime info about where a capability came from */
export interface CapabilitySource {
	type: CapabilitySourceType;
	/** For git-sourced capabilities: the source URL/shorthand */
	gitSource?: string;
	/** For git-sourced capabilities: the pinned ref if any */
	ref?: string;
	/** For git-sourced capabilities: the current commit hash */
	commit?: string;
	/** Version from capability.toml or package.json */
	version?: string;
}

// Loaded Capability
export interface LoadedCapability {
	id: string;
	path: string;
	config: CapabilityConfig;
	skills: Skill[];
	rules: Rule[];
	docs: Doc[];
	subagents: Subagent[];
	commands: Command[];
	typeDefinitions?: string;
	gitignore?: string[];
	exports: Record<string, unknown>;
	/** Where this capability comes from */
	source?: CapabilitySource;
	/** Hooks configuration from hooks/hooks.toml */
	hooks?: CapabilityHooks;
}

// Adapter Types
export type ProviderId = Provider | (string & {});

export interface SyncBundle {
	capabilities: LoadedCapability[];
	skills: Skill[];
	rules: Rule[];
	docs: Doc[];
	commands: Command[];
	subagents: Subagent[];
	/** Merged hooks from all capabilities */
	hooks?: HooksConfig;
	/** Generated instructions content from rules and docs, embedded directly into provider files */
	instructionsContent: string;
}

export interface ProviderContext {
	projectRoot: string;
	config: OmniConfig;
	activeProfile?: string;
}

export interface ProviderInitResult {
	// What did the init action do?
	filesCreated?: string[];
	message?: string;
}

export interface ProviderSyncResult {
	// What did the sync action do?
	filesWritten: string[];
	filesDeleted: string[];
}

export interface ProviderManifest {
	// State for cleanup
	files: string[];
	lastSync: string;
}

export interface ProviderAdapter {
	id: ProviderId;
	displayName: string;

	// Optional: used by `omnidev init`
	init?(ctx: ProviderContext): Promise<ProviderInitResult>;

	// Main sync entrypoint
	sync(bundle: SyncBundle, ctx: ProviderContext): Promise<ProviderSyncResult>;

	// Optional cleanup hook (when provider removed or resources stale)
	cleanup?(manifest: ProviderManifest, ctx: ProviderContext): Promise<void>;
}
