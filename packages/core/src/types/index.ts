// Capability Export Types (for capability developers)
export * from "./capability-export.js";

// Capability Types
export interface CapabilityMetadata {
	id: string;
	name: string;
	version: string;
	description: string;
	/** Optional metadata about the capability author and source */
	metadata?: {
		author?: string;
		repository?: string;
		license?: string;
		/** True if this capability was auto-generated by wrapping a skills repo */
		wrapped?: boolean;
		/** For wrapped capabilities: the full commit hash */
		commit?: string;
	};
}

export interface CapabilityExports {
	module?: string;
	gitignore?: string[];
}

export interface EnvDeclaration {
	required?: boolean;
	secret?: boolean;
	default?: string;
}

export interface SyncConfig {
	on_sync?: string;
}

export interface CliConfig {
	commands?: string[];
}

export interface CapabilityConfig {
	capability: CapabilityMetadata;
	exports?: CapabilityExports;
	env?: Record<string, EnvDeclaration | Record<string, never>>;
	mcp?: McpConfig;
	sync?: SyncConfig;
	cli?: CliConfig;
}

export type McpTransport = "stdio" | "sse" | "http";

export interface McpToolSchema {
	name: string;
	description: string;
	inputSchema: Record<string, unknown>;
}

export interface McpConfig {
	command: string;
	args?: string[];
	env?: Record<string, string>;
	cwd?: string;
	transport?: McpTransport;
	tools?: McpToolSchema[];
}

// Content Types
export interface Skill {
	name: string;
	description: string;
	instructions: string;
	capabilityId: string;
}

export interface Rule {
	name: string;
	content: string;
	capabilityId: string;
}

export interface Doc {
	name: string;
	content: string;
	capabilityId: string;
}

export type SubagentModel = "sonnet" | "opus" | "haiku" | "inherit";
export type SubagentPermissionMode =
	| "default"
	| "acceptEdits"
	| "dontAsk"
	| "bypassPermissions"
	| "plan";

export interface SubagentHookConfig {
	matcher?: string;
	hooks: {
		type: "command";
		command: string;
	}[];
}

export interface SubagentHooks {
	PreToolUse?: SubagentHookConfig[];
	PostToolUse?: SubagentHookConfig[];
	Stop?: SubagentHookConfig[];
}

export interface Subagent {
	/** Unique identifier using lowercase letters and hyphens */
	name: string;
	/** When Claude should delegate to this subagent */
	description: string;
	/** System prompt that guides the subagent's behavior */
	systemPrompt: string;
	/** Tools the subagent can use (inherits all if omitted) */
	tools?: string[];
	/** Tools to deny (removed from inherited or specified list) */
	disallowedTools?: string[];
	/** Model to use: sonnet, opus, haiku, or inherit */
	model?: SubagentModel;
	/** Permission mode for the subagent */
	permissionMode?: SubagentPermissionMode;
	/** Skills to load into the subagent's context at startup */
	skills?: string[];
	/** Lifecycle hooks scoped to this subagent */
	hooks?: SubagentHooks;
	/** Capability that provides this subagent */
	capabilityId: string;
}

export interface Command {
	/** Command name (used as /command-name) */
	name: string;
	/** Brief description of what this command does */
	description: string;
	/** Optional allowed tools specification (e.g., "Bash(git add:*), Bash(git status:*)") */
	allowedTools?: string;
	/** Command prompt (markdown content with support for $ARGUMENTS, $1, $2, !`commands`, @files) */
	prompt: string;
	/** Capability that provides this command */
	capabilityId: string;
}

// Capability Source Types
// Sources: local (manual), git (version via package.json), hub (future)
export type CapabilitySourceType = "built-in" | "local" | "git" | "hub";

/** Configuration for a Git-sourced capability */
export interface GitCapabilitySourceConfig {
	/** Source URL or shorthand (e.g., "github:user/repo", "git@github.com:...") */
	source: string;
	/** Git ref to checkout: tag, branch, or commit hash */
	ref?: string;
	/** Subdirectory within the repo containing the capability */
	path?: string;
	/**
	 * Type of capability:
	 * - "full" (default): Repo has capability.toml, use as-is
	 * - "wrap": Auto-discover skills/agents/commands and generate capability.toml
	 */
	type?: "full" | "wrap";
}

/** Lock file entry for a capability (version tracking) */
export interface CapabilityLockEntry {
	/** Original source reference */
	source: string;
	/** Version from capability.toml or package.json */
	version: string;
	/** For git sources: exact commit hash */
	commit?: string;
	/** Pinned ref if specified */
	ref?: string;
	/** Last update timestamp (ISO 8601) */
	updated_at: string;
}

/** Lock file structure (.omni/capabilities.lock.toml) */
export interface CapabilitiesLockFile {
	capabilities: Record<string, CapabilityLockEntry>;
}

/** Capabilities configuration section in omni/config.toml */
export interface CapabilitiesConfig {
	/** List of enabled capability IDs */
	enable?: string[];
	/** List of disabled capability IDs */
	disable?: string[];
	/** Git-sourced capabilities: id -> source string or full config */
	sources?: Record<string, string | GitCapabilitySourceConfig>;
}

// Config Types
export interface ProfileConfig {
	capabilities?: string[];
}

export interface OmniConfig {
	project?: string;
	active_profile?: string;
	always_enabled_capabilities?: string[];
	env?: Record<string, string>;
	profiles?: Record<string, ProfileConfig>;
	providers?: {
		enabled?: Provider[];
	};
	/** Capabilities configuration (enable/disable, sources) */
	capabilities?: CapabilitiesConfig;
}

// Provider Types
export type Provider = "claude" | "codex";

export interface ProviderConfig {
	provider?: Provider;
	providers?: Provider[];
}

export function getActiveProviders(config: ProviderConfig): Provider[] {
	if (config.providers) return config.providers;
	if (config.provider) return [config.provider];
	return ["claude"]; // Default
}

/** Runtime info about where a capability came from */
export interface CapabilitySource {
	type: CapabilitySourceType;
	/** For git-sourced capabilities: the source URL/shorthand */
	gitSource?: string;
	/** For git-sourced capabilities: the pinned ref if any */
	ref?: string;
	/** For git-sourced capabilities: the current commit hash */
	commit?: string;
	/** Version from capability.toml or package.json */
	version?: string;
}

// Loaded Capability
export interface LoadedCapability {
	id: string;
	path: string;
	config: CapabilityConfig;
	skills: Skill[];
	rules: Rule[];
	docs: Doc[];
	subagents: Subagent[];
	commands: Command[];
	typeDefinitions?: string;
	gitignore?: string[];
	exports: Record<string, unknown>;
	/** Where this capability comes from */
	source?: CapabilitySource;
}
