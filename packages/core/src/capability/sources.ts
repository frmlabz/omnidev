/**
 * Git-sourced capabilities: fetching, wrapping, and version management
 *
 * This module handles:
 * - Cloning/fetching capabilities from Git repositories
 * - Wrapping external repos (discovering skills/agents/commands)
 * - Managing the capabilities.lock.toml file
 * - Version tracking and update detection
 */

import { existsSync } from "node:fs";
import { mkdir, readFile, writeFile, readdir, stat } from "node:fs/promises";
import { join } from "node:path";
import { parse as parseToml } from "smol-toml";
import type {
	OmniConfig,
	GitCapabilitySourceConfig,
	CapabilitiesLockFile,
	CapabilityLockEntry,
} from "../types/index.js";

// Local path for .omni directory
const OMNI_LOCAL = ".omni";

// Directory names to scan for content (singular and plural forms)
const SKILL_DIRS = ["skills", "skill"];
const AGENT_DIRS = ["agents", "agent", "subagents", "subagent"];
const COMMAND_DIRS = ["commands", "command"];
const RULE_DIRS = ["rules", "rule"];
const DOC_DIRS = ["docs", "doc", "documentation"];

// File patterns for each content type
const SKILL_FILES = ["SKILL.md", "skill.md", "Skill.md"];
const AGENT_FILES = ["AGENT.md", "agent.md", "Agent.md", "SUBAGENT.md", "subagent.md"];
const COMMAND_FILES = ["COMMAND.md", "command.md", "Command.md"];

export interface FetchResult {
	id: string;
	path: string;
	version: string;
	commit: string;
	updated: boolean;
	wrapped: boolean;
}

export interface SourceUpdateInfo {
	id: string;
	source: string;
	currentVersion: string;
	latestVersion: string;
	hasUpdate: boolean;
}

/**
 * Parse a capability source string or config into normalized form
 */
export function parseSourceConfig(
	source: string | GitCapabilitySourceConfig,
): GitCapabilitySourceConfig {
	if (typeof source === "string") {
		// Parse shorthand formats:
		// - "github:user/repo"
		// - "github:user/repo#ref"
		// - "git@github.com:user/repo.git"
		// - "https://github.com/user/repo.git"

		let sourceUrl = source;
		let ref: string | undefined;

		// Check for ref in github shorthand
		if (source.startsWith("github:") && source.includes("#")) {
			const parts = source.split("#");
			sourceUrl = parts[0] ?? source;
			ref = parts[1];
		}

		const result: GitCapabilitySourceConfig = { source: sourceUrl };
		if (ref) {
			result.ref = ref;
		}
		return result;
	}
	return source;
}

/**
 * Convert source to a git-cloneable URL
 */
export function sourceToGitUrl(source: string): string {
	if (source.startsWith("github:")) {
		const repo = source.replace("github:", "");
		return `https://github.com/${repo}.git`;
	}
	// Already a URL or SSH path
	return source;
}

/**
 * Get the path where a capability source will be stored
 */
export function getSourceCapabilityPath(id: string): string {
	return join(OMNI_LOCAL, "capabilities", id);
}

/**
 * Get the lock file path
 */
export function getLockFilePath(): string {
	return join(OMNI_LOCAL, "capabilities.lock.toml");
}

/**
 * Load the capabilities lock file
 */
export async function loadLockFile(): Promise<CapabilitiesLockFile> {
	const lockPath = getLockFilePath();
	if (!existsSync(lockPath)) {
		return { capabilities: {} };
	}

	try {
		const content = await readFile(lockPath, "utf-8");
		const parsed = parseToml(content) as Record<string, unknown>;
		const capabilities = parsed["capabilities"] as Record<string, CapabilityLockEntry> | undefined;
		return {
			capabilities: capabilities || {},
		};
	} catch {
		return { capabilities: {} };
	}
}

/**
 * Stringify a lock file to TOML format
 */
function stringifyLockFile(lockFile: CapabilitiesLockFile): string {
	const lines: string[] = [];

	for (const [id, entry] of Object.entries(lockFile.capabilities)) {
		lines.push(`[capabilities.${id}]`);
		lines.push(`source = "${entry.source}"`);
		lines.push(`version = "${entry.version}"`);
		if (entry.commit) {
			lines.push(`commit = "${entry.commit}"`);
		}
		if (entry.ref) {
			lines.push(`ref = "${entry.ref}"`);
		}
		lines.push(`updated_at = "${entry.updated_at}"`);
		lines.push("");
	}

	return lines.join("\n");
}

/**
 * Save the capabilities lock file
 */
export async function saveLockFile(lockFile: CapabilitiesLockFile): Promise<void> {
	const lockPath = getLockFilePath();

	// Ensure directory exists
	await mkdir(join(OMNI_LOCAL, "capabilities"), { recursive: true });

	const header = `# Auto-generated by OmniDev - DO NOT EDIT
# Records installed capability versions for reproducibility
# Last updated: ${new Date().toISOString()}

`;
	const content = header + stringifyLockFile(lockFile);
	await writeFile(lockPath, content, "utf-8");
}

/**
 * Get the current commit hash of a git repository
 */
async function getRepoCommit(repoPath: string): Promise<string> {
	const proc = Bun.spawn(["git", "rev-parse", "HEAD"], {
		cwd: repoPath,
		stdout: "pipe",
		stderr: "pipe",
	});
	const output = await new Response(proc.stdout).text();
	await proc.exited;
	return output.trim();
}

/**
 * Get short commit hash (7 chars)
 */
function shortCommit(commit: string): string {
	return commit.substring(0, 7);
}

/**
 * Clone a git repository
 */
async function cloneRepo(gitUrl: string, targetPath: string, ref?: string): Promise<void> {
	// Ensure parent directory exists
	await mkdir(join(targetPath, ".."), { recursive: true });

	const args = ["clone", "--depth", "1"];
	if (ref) {
		args.push("--branch", ref);
	}
	args.push(gitUrl, targetPath);

	const proc = Bun.spawn(["git", ...args], {
		stdout: "pipe",
		stderr: "pipe",
	});

	await proc.exited;

	if (proc.exitCode !== 0) {
		const stderr = await new Response(proc.stderr).text();
		throw new Error(`Failed to clone ${gitUrl}: ${stderr}`);
	}
}

/**
 * Fetch and update an existing repository
 */
async function fetchRepo(repoPath: string, ref?: string): Promise<boolean> {
	// Fetch latest
	const fetchProc = Bun.spawn(["git", "fetch", "--depth", "1", "origin"], {
		cwd: repoPath,
		stdout: "pipe",
		stderr: "pipe",
	});
	await fetchProc.exited;

	// Get current and remote commits
	const currentCommit = await getRepoCommit(repoPath);

	// Check remote commit
	const targetRef = ref || "HEAD";
	const lsProc = Bun.spawn(["git", "ls-remote", "origin", targetRef], {
		cwd: repoPath,
		stdout: "pipe",
		stderr: "pipe",
	});
	const lsOutput = await new Response(lsProc.stdout).text();
	await lsProc.exited;

	const remoteCommit = lsOutput.split("\t")[0];

	if (currentCommit === remoteCommit) {
		return false; // No update
	}

	// Pull changes
	const pullProc = Bun.spawn(["git", "pull", "--ff-only"], {
		cwd: repoPath,
		stdout: "pipe",
		stderr: "pipe",
	});
	await pullProc.exited;

	return true; // Updated
}

/**
 * Check if a directory contains a capability.toml
 */
function hasCapabilityToml(dirPath: string): boolean {
	return existsSync(join(dirPath, "capability.toml"));
}

/**
 * Find directories matching any of the given names
 */
async function findMatchingDirs(basePath: string, names: string[]): Promise<string | null> {
	for (const name of names) {
		const dirPath = join(basePath, name);
		if (existsSync(dirPath)) {
			const stats = await stat(dirPath);
			if (stats.isDirectory()) {
				return dirPath;
			}
		}
	}
	return null;
}

/**
 * Find content files in a directory (skills, agents, commands)
 */
async function findContentItems(
	dirPath: string,
	filePatterns: string[],
): Promise<Array<{ name: string; path: string; isFolder: boolean }>> {
	const items: Array<{ name: string; path: string; isFolder: boolean }> = [];

	if (!existsSync(dirPath)) {
		return items;
	}

	const entries = await readdir(dirPath, { withFileTypes: true });

	for (const entry of entries) {
		const entryPath = join(dirPath, entry.name);

		if (entry.isDirectory()) {
			// Check for content file inside directory
			for (const pattern of filePatterns) {
				if (existsSync(join(entryPath, pattern))) {
					items.push({
						name: entry.name,
						path: entryPath,
						isFolder: true,
					});
					break;
				}
			}
		} else if (entry.isFile() && entry.name.endsWith(".md")) {
			// Single file content (e.g., agents/researcher.md)
			const name = entry.name.replace(/\.md$/i, "");
			items.push({
				name,
				path: entryPath,
				isFolder: false,
			});
		}
	}

	return items;
}

/**
 * Discover content in a wrapped repository
 */
export interface DiscoveredContent {
	skills: Array<{ name: string; path: string; isFolder: boolean }>;
	agents: Array<{ name: string; path: string; isFolder: boolean }>;
	commands: Array<{ name: string; path: string; isFolder: boolean }>;
	rulesDir: string | null;
	docsDir: string | null;
}

async function discoverContent(repoPath: string): Promise<DiscoveredContent> {
	const result: DiscoveredContent = {
		skills: [],
		agents: [],
		commands: [],
		rulesDir: null,
		docsDir: null,
	};

	// Find skills
	const skillsDir = await findMatchingDirs(repoPath, SKILL_DIRS);
	if (skillsDir) {
		result.skills = await findContentItems(skillsDir, SKILL_FILES);
	}

	// Find agents
	const agentsDir = await findMatchingDirs(repoPath, AGENT_DIRS);
	if (agentsDir) {
		result.agents = await findContentItems(agentsDir, AGENT_FILES);
	}

	// Find commands
	const commandsDir = await findMatchingDirs(repoPath, COMMAND_DIRS);
	if (commandsDir) {
		result.commands = await findContentItems(commandsDir, COMMAND_FILES);
	}

	// Find rules directory
	result.rulesDir = await findMatchingDirs(repoPath, RULE_DIRS);

	// Find docs directory
	result.docsDir = await findMatchingDirs(repoPath, DOC_DIRS);

	return result;
}

/**
 * Generate a capability.toml for a wrapped repository
 */
async function generateCapabilityToml(
	id: string,
	repoPath: string,
	source: string,
	commit: string,
	content: DiscoveredContent,
): Promise<void> {
	const shortHash = shortCommit(commit);

	// Build description based on discovered content
	const parts: string[] = [];
	if (content.skills.length > 0) {
		parts.push(`${content.skills.length} skill${content.skills.length > 1 ? "s" : ""}`);
	}
	if (content.agents.length > 0) {
		parts.push(`${content.agents.length} agent${content.agents.length > 1 ? "s" : ""}`);
	}
	if (content.commands.length > 0) {
		parts.push(`${content.commands.length} command${content.commands.length > 1 ? "s" : ""}`);
	}

	const description =
		parts.length > 0 ? `Wrapped from ${source} (${parts.join(", ")})` : `Wrapped from ${source}`;

	// Extract repository URL for metadata
	const repoUrl = source.startsWith("github:")
		? `https://github.com/${source.replace("github:", "")}`
		: source;

	const tomlContent = `# Auto-generated by OmniDev - DO NOT EDIT
# This capability was wrapped from an external repository

[capability]
id = "${id}"
name = "${id} (wrapped)"
version = "${shortHash}"
description = "${description}"

[capability.metadata]
repository = "${repoUrl}"
wrapped = true
commit = "${commit}"
`;

	await writeFile(join(repoPath, "capability.toml"), tomlContent, "utf-8");
}

/**
 * Fetch a single capability source
 */
export async function fetchCapabilitySource(
	id: string,
	sourceConfig: string | GitCapabilitySourceConfig,
	options?: { silent?: boolean },
): Promise<FetchResult> {
	const config = parseSourceConfig(sourceConfig);
	const gitUrl = sourceToGitUrl(config.source);
	const targetPath = getSourceCapabilityPath(id);
	const isWrap = config.type === "wrap";

	let updated = false;
	let commit: string;

	// Check if already cloned
	if (existsSync(join(targetPath, ".git"))) {
		// Fetch updates
		if (!options?.silent) {
			console.log(`  Checking ${id}...`);
		}
		updated = await fetchRepo(targetPath, config.ref);
		commit = await getRepoCommit(targetPath);
	} else {
		// Clone repository
		if (!options?.silent) {
			console.log(`  Cloning ${id} from ${config.source}...`);
		}
		await cloneRepo(gitUrl, targetPath, config.ref);
		commit = await getRepoCommit(targetPath);
		updated = true;
	}

	// Check if we need to wrap (no capability.toml or explicitly wrap type)
	const needsWrap = isWrap || !hasCapabilityToml(targetPath);

	if (needsWrap && updated) {
		// Discover content and generate capability.toml
		const content = await discoverContent(targetPath);
		await generateCapabilityToml(id, targetPath, config.source, commit, content);

		if (!options?.silent) {
			const parts: string[] = [];
			if (content.skills.length > 0) parts.push(`${content.skills.length} skills`);
			if (content.agents.length > 0) parts.push(`${content.agents.length} agents`);
			if (content.commands.length > 0) parts.push(`${content.commands.length} commands`);
			if (parts.length > 0) {
				console.log(`    Wrapped: ${parts.join(", ")}`);
			}
		}
	}

	// Get version from capability.toml or package.json
	let version = shortCommit(commit);
	const pkgJsonPath = join(targetPath, "package.json");
	if (existsSync(pkgJsonPath)) {
		try {
			const pkgJson = JSON.parse(await readFile(pkgJsonPath, "utf-8"));
			if (pkgJson.version) {
				version = pkgJson.version;
			}
		} catch {
			// Ignore parse errors
		}
	}

	return {
		id,
		path: targetPath,
		version,
		commit,
		updated,
		wrapped: needsWrap,
	};
}

/**
 * Fetch all capability sources from config
 */
export async function fetchAllCapabilitySources(
	config: OmniConfig,
	options?: { silent?: boolean; force?: boolean },
): Promise<FetchResult[]> {
	const sources = config.capabilities?.sources;
	if (!sources || Object.keys(sources).length === 0) {
		return [];
	}

	if (!options?.silent) {
		console.log("Fetching capability sources...");
	}

	const results: FetchResult[] = [];
	const lockFile = await loadLockFile();
	let lockUpdated = false;

	for (const [id, source] of Object.entries(sources)) {
		try {
			const result = await fetchCapabilitySource(id, source, options);
			results.push(result);

			// Update lock file
			const lockEntry: CapabilityLockEntry = {
				source: typeof source === "string" ? source : source.source,
				version: result.version,
				commit: result.commit,
				updated_at: new Date().toISOString(),
			};

			const sourceConfig = parseSourceConfig(source);
			if (sourceConfig.ref) {
				lockEntry.ref = sourceConfig.ref;
			}

			// Check if lock entry changed
			const existing = lockFile.capabilities[id];
			if (!existing || existing.commit !== result.commit) {
				lockFile.capabilities[id] = lockEntry;
				lockUpdated = true;

				if (!options?.silent && result.updated) {
					const oldVersion = existing?.version || "new";
					console.log(`  ${result.wrapped ? "+" : "~"} ${id}: ${oldVersion} -> ${result.version}`);
				}
			}
		} catch (error) {
			console.error(`  Failed to fetch ${id}: ${error}`);
		}
	}

	// Save lock file if changed
	if (lockUpdated) {
		await saveLockFile(lockFile);
	}

	if (!options?.silent && results.length > 0) {
		const updated = results.filter((r) => r.updated).length;
		if (updated > 0) {
			console.log(`  Updated ${updated} capability source(s)`);
		} else {
			console.log(`  All ${results.length} source(s) up to date`);
		}
	}

	return results;
}

/**
 * Check for available updates without applying them
 */
export async function checkForUpdates(config: OmniConfig): Promise<SourceUpdateInfo[]> {
	const sources = config.capabilities?.sources;
	if (!sources || Object.keys(sources).length === 0) {
		return [];
	}

	const lockFile = await loadLockFile();
	const updates: SourceUpdateInfo[] = [];

	for (const [id, source] of Object.entries(sources)) {
		const sourceConfig = parseSourceConfig(source);
		const targetPath = getSourceCapabilityPath(id);
		const existing = lockFile.capabilities[id];

		if (!existsSync(join(targetPath, ".git"))) {
			// Not yet cloned
			updates.push({
				id,
				source: sourceConfig.source,
				currentVersion: "not installed",
				latestVersion: "unknown",
				hasUpdate: true,
			});
			continue;
		}

		// Fetch to check for updates (without pulling)
		const fetchProc = Bun.spawn(["git", "fetch", "--depth", "1", "origin"], {
			cwd: targetPath,
			stdout: "pipe",
			stderr: "pipe",
		});
		await fetchProc.exited;

		// Get remote commit
		const targetRef = sourceConfig.ref || "HEAD";
		const lsProc = Bun.spawn(["git", "ls-remote", "origin", targetRef], {
			cwd: targetPath,
			stdout: "pipe",
			stderr: "pipe",
		});
		const lsOutput = await new Response(lsProc.stdout).text();
		await lsProc.exited;

		const remoteCommit = lsOutput.split("\t")[0] || "";
		const currentCommit = existing?.commit || "";

		updates.push({
			id,
			source: sourceConfig.source,
			currentVersion: existing?.version || (currentCommit ? shortCommit(currentCommit) : "unknown"),
			latestVersion: remoteCommit ? shortCommit(remoteCommit) : "unknown",
			hasUpdate: currentCommit !== remoteCommit,
		});
	}

	return updates;
}
