import { buildCommand, buildRouteMap } from '@stricli/core';
import { mkdirSync } from 'node:fs';

export async function runTypesGenerate(): Promise<void> {
	const { buildCapabilityRegistry } = await import('@omnidev/core');

	console.log('Generating type definitions...');

	const registry = await buildCapabilityRegistry();
	const capabilities = registry.getAllCapabilities();

	// Ensure directory exists
	mkdirSync('.omni/generated', { recursive: true });

	// Collect all type definitions from enabled capabilities
	const typeDefinitions = capabilities
		.map((cap) => cap.typeDefinitions)
		.filter((def): def is string => def !== undefined && def.trim().length > 0);

	// Generate .omni/generated/types.d.ts
	const typesContent = generateTypesFile(typeDefinitions);
	await Bun.write('.omni/generated/types.d.ts', typesContent);

	console.log('âœ“ Generated:');
	console.log('  - .omni/generated/types.d.ts');
	console.log(`  - ${typeDefinitions.length} capability type definitions included`);
}

function generateTypesFile(typeDefinitions: string[]): string {
	let content = `// Type Definitions
// Generated by OmniDev
// Run \`omnidev types generate\` to regenerate

`;

	if (typeDefinitions.length === 0) {
		content += '// No type definitions available from enabled capabilities\n';
	} else {
		for (const typeDef of typeDefinitions) {
			content += `${typeDef.trim()}\n\n`;
		}
	}

	return content;
}

export const typesRoutes = buildRouteMap({
	routes: {
		generate: buildCommand({
			docs: {
				brief: 'Generate type definitions from enabled capabilities',
			},
			parameters: {},
			func: runTypesGenerate,
		}),
	},
	docs: {
		brief: 'Manage type definitions',
	},
});
