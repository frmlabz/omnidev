import { afterEach, beforeEach, describe, expect, test } from 'bun:test';
import { existsSync, mkdirSync, rmSync } from 'node:fs';
import { join } from 'node:path';
import { runTypesGenerate } from './types';

describe('types generate command', () => {
	let testDir: string;
	let originalCwd: string;

	beforeEach(() => {
		originalCwd = process.cwd();
		testDir = join(import.meta.dir, `test-types-${Date.now()}-${Math.random()}`);
		mkdirSync(testDir, { recursive: true });
		process.chdir(testDir);

		// Create omni directory structure
		mkdirSync('omni/capabilities', { recursive: true });
		mkdirSync('.omni', { recursive: true });
	});

	afterEach(() => {
		process.chdir(originalCwd);
		if (existsSync(testDir)) {
			rmSync(testDir, { recursive: true, force: true });
		}
	});

	test('should create required directory', async () => {
		// Create minimal config
		await Bun.write(
			'omni/config.toml',
			`project = "test"
[capabilities]
enable = []`,
		);

		await runTypesGenerate();

		expect(existsSync('.omni/generated')).toBe(true);
	});

	test('should generate types.d.ts with no capabilities', async () => {
		// Create minimal config
		await Bun.write(
			'omni/config.toml',
			`project = "test"
[capabilities]
enable = []`,
		);

		await runTypesGenerate();

		expect(existsSync('.omni/generated/types.d.ts')).toBe(true);
		const content = await Bun.file('.omni/generated/types.d.ts').text();
		expect(content).toContain('// Type Definitions');
		expect(content).toContain('// Generated by OmniDev');
		expect(content).toContain('// No type definitions available from enabled capabilities');
	});

	test('should include type definitions from a capability', async () => {
		// Create a test capability with types
		const capPath = 'omni/capabilities/test-cap';
		mkdirSync(capPath, { recursive: true });

		await Bun.write(
			join(capPath, 'capability.toml'),
			`[capability]
id = "test-cap"
name = "Test Capability"
version = "1.0.0"
description = "A test capability"`,
		);

		await Bun.write(
			join(capPath, 'types.d.ts'),
			`export function testFunction(): void;
export interface TestInterface {
	id: string;
	name: string;
}`,
		);

		await Bun.write(
			'omni/config.toml',
			`project = "test"
[capabilities]
enable = ["test-cap"]`,
		);

		await runTypesGenerate();

		expect(existsSync('.omni/generated/types.d.ts')).toBe(true);
		const content = await Bun.file('.omni/generated/types.d.ts').text();
		expect(content).toContain('export function testFunction(): void;');
		expect(content).toContain('export interface TestInterface');
		expect(content).toContain('id: string;');
		expect(content).toContain('name: string;');
	});

	test('should include type definitions from multiple capabilities', async () => {
		// Create first capability
		const cap1Path = 'omni/capabilities/cap-one';
		mkdirSync(cap1Path, { recursive: true });

		await Bun.write(
			join(cap1Path, 'capability.toml'),
			`[capability]
id = "cap-one"
name = "Capability One"
version = "1.0.0"
description = "First capability"`,
		);

		await Bun.write(join(cap1Path, 'types.d.ts'), `export function functionOne(): void;`);

		// Create second capability
		const cap2Path = 'omni/capabilities/cap-two';
		mkdirSync(cap2Path, { recursive: true });

		await Bun.write(
			join(cap2Path, 'capability.toml'),
			`[capability]
id = "cap-two"
name = "Capability Two"
version = "1.0.0"
description = "Second capability"`,
		);

		await Bun.write(join(cap2Path, 'types.d.ts'), `export function functionTwo(): void;`);

		await Bun.write(
			'omni/config.toml',
			`project = "test"
[capabilities]
enable = ["cap-one", "cap-two"]`,
		);

		await runTypesGenerate();

		const content = await Bun.file('.omni/generated/types.d.ts').text();
		expect(content).toContain('export function functionOne(): void;');
		expect(content).toContain('export function functionTwo(): void;');
	});

	test('should handle capabilities without type definitions', async () => {
		// Create a capability without types.d.ts
		const capPath = 'omni/capabilities/no-types-cap';
		mkdirSync(capPath, { recursive: true });

		await Bun.write(
			join(capPath, 'capability.toml'),
			`[capability]
id = "no-types-cap"
name = "No Types Capability"
version = "1.0.0"
description = "A capability without types"`,
		);

		await Bun.write(
			'omni/config.toml',
			`project = "test"
[capabilities]
enable = ["no-types-cap"]`,
		);

		await runTypesGenerate();

		expect(existsSync('.omni/generated/types.d.ts')).toBe(true);
		const content = await Bun.file('.omni/generated/types.d.ts').text();
		expect(content).toContain('// No type definitions available from enabled capabilities');
	});

	test('should handle mixed capabilities (some with types, some without)', async () => {
		// Create capability with types
		const cap1Path = 'omni/capabilities/with-types';
		mkdirSync(cap1Path, { recursive: true });

		await Bun.write(
			join(cap1Path, 'capability.toml'),
			`[capability]
id = "with-types"
name = "With Types"
version = "1.0.0"
description = "Has types"`,
		);

		await Bun.write(join(cap1Path, 'types.d.ts'), `export function myFunction(): void;`);

		// Create capability without types
		const cap2Path = 'omni/capabilities/without-types';
		mkdirSync(cap2Path, { recursive: true });

		await Bun.write(
			join(cap2Path, 'capability.toml'),
			`[capability]
id = "without-types"
name = "Without Types"
version = "1.0.0"
description = "No types"`,
		);

		await Bun.write(
			'omni/config.toml',
			`project = "test"
[capabilities]
enable = ["with-types", "without-types"]`,
		);

		await runTypesGenerate();

		const content = await Bun.file('.omni/generated/types.d.ts').text();
		expect(content).toContain('export function myFunction(): void;');
		expect(content).not.toContain('// No type definitions available');
	});

	test('should overwrite existing types.d.ts', async () => {
		// Create initial config and run generate
		await Bun.write(
			'omni/config.toml',
			`project = "test"
[capabilities]
enable = []`,
		);

		await runTypesGenerate();

		// Modify the generated file
		await Bun.write('.omni/generated/types.d.ts', 'export const OLD_CONTENT = true;');

		// Run generate again
		await runTypesGenerate();

		// Should have new content
		const content = await Bun.file('.omni/generated/types.d.ts').text();
		expect(content).toContain('// Type Definitions');
		expect(content).not.toContain('OLD_CONTENT');
	});

	test('should respect profile-based capability filtering', async () => {
		// Create two capabilities with different types
		const cap1Path = 'omni/capabilities/cap-one';
		mkdirSync(cap1Path, { recursive: true });

		await Bun.write(
			join(cap1Path, 'capability.toml'),
			`[capability]
id = "cap-one"
name = "Capability One"
version = "1.0.0"
description = "First capability"`,
		);

		await Bun.write(join(cap1Path, 'types.d.ts'), `export function capOneFunction(): void;`);

		const cap2Path = 'omni/capabilities/cap-two';
		mkdirSync(cap2Path, { recursive: true });

		await Bun.write(
			join(cap2Path, 'capability.toml'),
			`[capability]
id = "cap-two"
name = "Capability Two"
version = "1.0.0"
description = "Second capability"`,
		);

		await Bun.write(join(cap2Path, 'types.d.ts'), `export function capTwoFunction(): void;`);

		// Config enables only cap-one
		await Bun.write(
			'omni/config.toml',
			`project = "test"
default_profile = "default"
[capabilities]
enable = ["cap-one"]
[profiles.default]`,
		);

		await runTypesGenerate();

		const content = await Bun.file('.omni/generated/types.d.ts').text();
		expect(content).toContain('export function capOneFunction(): void;');
		expect(content).not.toContain('export function capTwoFunction(): void;');
	});

	test('should handle capability loading errors gracefully', async () => {
		// Create a capability with invalid config
		const capPath = 'omni/capabilities/invalid-cap';
		mkdirSync(capPath, { recursive: true });

		await Bun.write(join(capPath, 'capability.toml'), 'invalid toml [[[');

		await Bun.write(
			'omni/config.toml',
			`project = "test"
[capabilities]
enable = []`,
		);

		// Should not throw
		await runTypesGenerate();

		// Should still create base file
		expect(existsSync('.omni/generated/types.d.ts')).toBe(true);
	});

	test('should trim whitespace from type definitions', async () => {
		const capPath = 'omni/capabilities/test-cap';
		mkdirSync(capPath, { recursive: true });

		await Bun.write(
			join(capPath, 'capability.toml'),
			`[capability]
id = "test-cap"
name = "Test Capability"
version = "1.0.0"
description = "A test capability"`,
		);

		await Bun.write(
			join(capPath, 'types.d.ts'),
			`

export function testFunction(): void;


`,
		);

		await Bun.write(
			'omni/config.toml',
			`project = "test"
[capabilities]
enable = ["test-cap"]`,
		);

		await runTypesGenerate();

		const content = await Bun.file('.omni/generated/types.d.ts').text();
		expect(content).toContain('export function testFunction(): void;');
		// Should not have excessive whitespace
		expect(content.split('\n').filter((line) => line.trim() === '').length).toBeLessThan(5);
	});

	test('should handle empty type definitions', async () => {
		const capPath = 'omni/capabilities/empty-types';
		mkdirSync(capPath, { recursive: true });

		await Bun.write(
			join(capPath, 'capability.toml'),
			`[capability]
id = "empty-types"
name = "Empty Types"
version = "1.0.0"
description = "Empty types file"`,
		);

		// Create empty types.d.ts file
		await Bun.write(join(capPath, 'types.d.ts'), '   \n\n   ');

		await Bun.write(
			'omni/config.toml',
			`project = "test"
[capabilities]
enable = ["empty-types"]`,
		);

		await runTypesGenerate();

		const content = await Bun.file('.omni/generated/types.d.ts').text();
		expect(content).toContain('// No type definitions available from enabled capabilities');
	});
});
